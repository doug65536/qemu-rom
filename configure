#!/bin/bash

function fail() {
    echo Failed: "$@" 1>&2
    exit 1
}

HOST=${HOST:-x86_64-dgos}
ARCH=${ARCH:-${HOST%%-*}}    # x86_64
HOSTOS=${HOST#*-}            # dgos
COMPILER_PREFIX=${COMPILER_PREFIX:-"$HOST-"}
echo Compiler prefix is $COMPILER_PREFIX

WHICH=${WHICH:-which}
WHICH=$("$WHICH" -- "$WHICH") || \
		fail Error getting full path to \"which\"

echo -- Configuring for $ARCH

case "$ARCH" in
aarch64)
    if [[ -z $GDB ]]; then
        GDB=${GDB:-gdb-multiarch}
    fi
    LINKER_EMULATION=aarch64elf
    QEMU_MACHINE=${QEMU_MACHINE:-$(printf "%s " \
        "-M virt" 
        "-machine gic-version=3" 
        "-machine virtualization=true"
        "-machine secure=true")}
    QEMU_CPU=${QEMU_CPU:-"-cpu cortex-a72"}
    MARCH_FLAGS=${MARCH_FLAGS:--march=armv8-a}
    DEBUG_CON=${DEBUG_CON:--serial stdio}
    GDB_EXTRA_STARTUP_CMD='-ex '$'\'''set architecture aarch64'$'\''
    ;;
    
x86_64)
    LINKER_EMULATION=${LINKER_EMULATION:-elf_${ARCH}}
    MARCH_FLAGS=${MARCH_FLAGS:-}
    DEBUG_CON=${DEBUG_CON:--device isa-debugcon,chardev=debug-out}
    GDB_EXTRA_STARTUP_CMD='-ex '$'\'''set architecture i386:x86-64'$'\''
    ;;
    
i386)
    # Force it back to x86_64 toolchain, but use m32
    #COMPILER_PREFIX=x86_64-$HOSTOS-
    LINKER_EMULATION=${LINKER_EMULATION:-elf_${ARCH}}
    MARCH_FLAGS=${MARCH_FLAGS:-march=i686}
    DEBUG_CON=${DEBUG_CON:--device isa-debugcon,chardev=debug-out}
    GDB_EXTRA_STARTUP_CMD='-ex '$'\'''set architecture i386'$'\''
    ;;
    
esac

declare -A PROGRAMS=(
    ["CXX"]=${CXX:-${COMPILER_PREFIX}g++}
    ["OBJCOPY"]=${OBJCOPY:-${COMPILER_PREFIX}objcopy}
    ["OBJDUMP"]=${OBJDUMP:-${COMPILER_PREFIX}objdump}
    ["GDB"]=${GDB:-${COMPILER_PREFIX}gdb}
    ["QEMU"]=${QEMU:-qemu-system-$ARCH}
    ["LN"]=${LN:-ln}
    ["CP"]=${CP:-cp}
    ["CHMOD"]=${CHMOD:-chmod}
    ["CMP"]=${CMP:-cmp}
    ["RM"]=${RM:-rm}
    ["MV"]=${MV:-mv}
    ["REALPATH"]=${REALPATH:-realpath}
    ["TOUCH"]=${TOUCH:-touch}
    ["LESS"]=${LESS:-less}
)

declare -A RESOLVED_PROGRAMS=()

# Create variables from what `which` returns for them all
for name in "${!PROGRAMS[@]}"; do
    value="${PROGRAMS["$name"]}"
    loc=$("$WHICH" -- "$value") || fail Failed to find $value for $name
    
    # It is almost universally a bad idea to modify an associative 
    # array while it is being iterated, so put the translated 
    # information in another associative array
    RESOLVED_PROGRAMS+=(["$name"]=$loc)
    
    eval "$name=$loc"
done

# Then copy the updated information back into the desired storage location
for name in "${!RESOLVED_PROGRAMS[@]}"; do
    PROGRAMS+=(["$name"]=${RESOLVED_PROGRAMS["$name"]})
done
RESOLVED_PROGRAMS=()

ABS_SRC_DIR="$( cd "$( dirname \
        "${BASH_SOURCE[0]}" )"&> /dev/null && pwd )" || exit

SRC_DIR=$("$REALPATH" --relative-to="." "$ABS_SRC_DIR") || \
        fail Unable to deduce relative path to source

if [[ $LIBGCC == "" ]]; then
    if [[ $ARCH == "x86_64" ]]; then
        LIBGCC=$("$CXX" -print-libgcc-file-name) || \
                fail getting m32 libgcc path failed
    elif [[ $ARCH == "i386" ]]; then
        LIBGCC=$("$CXX"  -m32 -print-libgcc-file-name) || \
                fail getting m32 libgcc path failed
    elif [[ $ARCH == "aarch64" ]]; then
        LIBGCC=$("$CXX" -print-libgcc-file-name) || \
                fail getting aarch64 libgcc path failed
    else
        fail Unknown architecture
    fi
fi
trap '"$RM" -f "$TMPFILE"' EXIT

TMPFILE=$(mktemp) || fail Could not create temp file

declare -a PASSTHRU=(
    "ARCH"
    "MARCH_FLAGS"
    "LINKER_EMULATION"
    "QEMU_MACHINE"
    "HOSTOS"
    "SRC_DIR"
    "COMPILER_PREFIX"
    "LIBGCC"
    "DEBUG_CON"
    "GDB_EXTRA_STARTUP_CMD"
)

printf '# This file was automatically generated by %s/configure\n' \
        >> "$TMPFILE" || fail Unable to create new config.mk

for name in "${PASSTHRU[@]}"; do
    printf 'export %s=%s\n' "$name" "${!name}" >> "$TMPFILE" || \
        fail Write error generating config.mk
done

for name in "${!PROGRAMS[@]}"; do
    printf 'export %s=%s\n' "$name" "${PROGRAMS["$name"]}" >> "$TMPFILE" || \
            fail Write error
done

if ! "$CMP" -s "$TMPFILE" config.mk; then
    echo 'Updated config.mk'
    "$MV" -f "$TMPFILE" config.mk || fail Moving config.mk into place failed
else
    "$TOUCH" config.mk || fail Touching config.mk failed
fi

if ! "$CMP" -s "${SRC_DIR}/Makefile" Makefile; then
    echo 'Updated makefile'
    "$CP" -u --preserve=timestamps "${SRC_DIR}/Makefile" Makefile || \
            fail Unable to update Makefile
fi
