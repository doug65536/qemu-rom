#!/bin/bash

function fail() {
    echo Failed: "$@" 1>&2
    exit 1
}

export HOST=${HOST:-x86_64-dgos}
export ARCH=${ARCH:-${HOST%%-*}}    # x86_64
export HOSTOS=${HOST#*-}            # dgos
export COMPILER_PREFIX=${COMPILER_PREFIX:-"$HOST-"}
echo Compiler prefix is $COMPILER_PREFIX

export WHICH=${WHICH:-which}
export WHICH=$("$WHICH" -- "$WHICH") || \
		fail Error getting full path to \"which\"

echo -- Configuring for $ARCH

case "$ARCH" in
aarch64)
    if [[ -z $GDB ]]; then
        export GDB=${GDB:-gdb-multiarch}
    fi
    export LINKER_EMULATION=aarch64elf
    export QEMU_MACHINE=${QEMU_MACHINE:-"-M virt -machine gic-version=3 -machine virtualization=true -machine secure=true"}
    export QEMU_CPU=${QEMU_CPU:-"-cpu cortex-a72"}
    export MCPU_FLAG=${MCPU_FLAG:--march=armv8-a}
    export DEBUG_CON=${DEBUG_CON:--serial stdio}
    export GDB_EXTRA_STARTUP_CMD='-ex '$'\'''set architecture aarch64'$'\''
    ;;
    
x86_64)
    export LINKER_EMULATION=${LINKER_EMULATION:-elf_${ARCH}}
    export MCPU_FLAG=${MCPU_FLAG:-}
    export DEBUG_CON=${DEBUG_CON:--device isa-debugcon,chardev=debug-out}
    export GDB_EXTRA_STARTUP_CMD='-ex '$'\'''set architecture i386:x86-64'$'\''
    ;;
    
i386)
    # Force it back to x86_64 toolchain, but use m32
    export COMPILER_PREFIX=x86_64-$HOSTOS-
    export LINKER_EMULATION=${LINKER_EMULATION:-elf_${ARCH}}
    export MCPU_FLAG=${MCPU_FLAG:-}
    export DEBUG_CON=${DEBUG_CON:--device isa-debugcon,chardev=debug-out}
    export GDB_EXTRA_STARTUP_CMD='-ex '$'\'''set architecture i386'$'\''
    ;;
    
esac

declare -A PROGRAMS=(
    ["CXX"]=${CXX:-${COMPILER_PREFIX}g++}
    ["OBJCOPY"]=${OBJCOPY:-${COMPILER_PREFIX}objcopy}
    ["GDB"]=${GDB:-${COMPILER_PREFIX}gdb}
    ["QEMU"]=${QEMU:-qemu-system-$ARCH}
    ["LN"]=${LN:-ln}
    ["CP"]=${CP:-cp}
    ["CHMOD"]=${CHMOD:-chmod}
    ["CMP"]=${CMP:-cmp}
    ["RM"]=${RM:-rm}
    ["MV"]=${MV:-mv}
    ["REALPATH"]=${REALPATH:-realpath}
    ["TOUCH"]=${TOUCH:-touch}
)

declare -A RESOLVED_PROGRAMS=()

# Create variables from what `which` returns for them all
for name in "${!PROGRAMS[@]}"; do
    value="${PROGRAMS["$name"]}"
    loc=$("$WHICH" -- "$value") || fail Failed to find $value for $name
    
    # It is almost universally a bad idea to modify an associative 
    # array while it is being iterated, so put the translated 
    # information in another associative array
    RESOLVED_PROGRAMS+=(["$name"]=$loc)
    
    eval export "$name=$loc"
done

# Then copy the updated information back into the desired storage location
for name in "${!RESOLVED_PROGRAMS[@]}"; do
    PROGRAMS+=(["$name"]=${RESOLVED_PROGRAMS["$name"]})
done
RESOLVED_PROGRAMS=()

export ABS_SRC_DIR="$( cd "$( dirname \
        "${BASH_SOURCE[0]}" )"&> /dev/null && pwd )" || exit

export SRC_DIR=$("$REALPATH" --relative-to="." "$ABS_SRC_DIR") || \
        fail Unable to deduce relative path to source

if [[ $LIBGCC == "" ]]; then
    if [[ $ARCH == "x86_64" ]]; then
        LIBGCC=$("$CXX" -print-libgcc-file-name) || \
                fail getting m32 libgcc path failed
    elif [[ $ARCH == "i386" ]]; then
        LIBGCC=$("$CXX"  -m32 -print-libgcc-file-name) || \
                fail getting m32 libgcc path failed
    elif [[ $ARCH == "aarch64" ]]; then
        LIBGCC=$("$CXX" -print-libgcc-file-name) || \
                fail getting aarch64 libgcc path failed
    else
        fail Unknown architecture
    fi
fi
trap '"$RM" -f "$TMPFILE"' EXIT

TMPFILE=$(mktemp) || fail Could not create temp file

declare -a PASSTHRU=(
    "ARCH"
    "LINKER_EMULATION"
    "QEMU_MACHINE"
    "HOSTOS"
    "SRC_DIR"
    "COMPILER_PREFIX"
    "LIBGCC"
    "GDB_EXTRA_STARTUP_CMD"
)

printf '# This file was automatically generated by %s/configure\n' \
        >> "$TMPFILE" || fail Unable to create new config.mk

for name in "${PASSTHRU[@]}"; do
    printf 'export %s=%s\n' "$name" "${!name}" >> "$TMPFILE" || \
        fail Write error generating config.mk
done

for name in "${!PROGRAMS[@]}"; do
    printf 'export %s=%s\n' "$name" "${PROGRAMS["$name"]}" >> "$TMPFILE" || \
            fail Write error
done

if ! "$CMP" -s "$TMPFILE" config.mk; then
    echo 'Updated config.mk'
    "$MV" -f "$TMPFILE" config.mk || fail Moving config.mk into place failed
else
    "$TOUCH" config.mk || fail Touching config.mk failed
fi

if ! "$CMP" -s "${SRC_DIR}/Makefile" Makefile; then
    echo 'Updated makefile'
    "$CP" -u --preserve=timestamps "${SRC_DIR}/Makefile" Makefile || \
            fail Unable to update Makefile
fi
